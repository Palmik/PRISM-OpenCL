#ifndef FOXGLYNN_OPENCL_KERNEL_SOURCE
#define FOXGLYNN_OPENCL_KERNEL_SOURCE

static char const* FGOpenCLSrc =
"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\r\n\r\ntypedef double real;\r\n\r\n__kernel void FGCoreCS_FW\r\n ( const uint warp_size\r\n , __global real const* fw_non_zero\r\n , __global uint const* fw_non_zero_row\r\n , __global uint const* fw_seg_offset\r\n , const uint fw_ns\r\n , const uint fw_ns_rem\r\n\r\n , __global real const* fgw_d\r\n , const real fgw_w\r\n , __global real* sum\r\n\r\n , __global real const* v0\r\n , __global real* v1\r\n )\r\n{\r\n int col = get_group_id(0) * get_local_size(0) + get_local_id(0);\r\n int seg_i = col / warp_size;\r\n int off_i = get_local_id(0) % warp_size;\r\n\r\n uint dim = (fw_ns - 1) * warp_size + fw_ns_rem;\r\n if (col < dim)\r\n {\r\n real dot_product = fgw_d[col] * v0[col];\r\n uint skip = (seg_i < fw_ns - 1) ? warp_size : fw_ns_rem;\r\n \r\n uint sb = fw_seg_offset[seg_i];\r\n uint se = fw_seg_offset[seg_i + 1];\r\n for (uint ii = sb + off_i; ii < se; ii += skip)\r\n {\r\n dot_product = fma(fw_non_zero[ii], v0[fw_non_zero_row[ii]], dot_product);\r\n }\r\n v1[col] = dot_product;\r\n\r\n sum[col] = fma(fgw_w, dot_product, sum[col]);\r\n }\r\n}\r\n\r\n__kernel void FGCoreCS\r\n ( __global real const* msc_non_zero\r\n , __global uint const* msc_non_zero_row\r\n , __global uint const* msc_column_offset\r\n , const uint msc_dim\r\n\r\n , __global real const* fgw_d\r\n , const real fgw_w\r\n , __global real* sum\r\n\r\n , __global real const* v0\r\n , __global real* v1\r\n )\r\n{\r\n int col = get_global_id(0);\r\n if (col < msc_dim)\r\n {\r\n uint cb = msc_column_offset[col];\r\n uint ce = msc_column_offset[col + 1];\r\n\r\n real dot_product = fgw_d[col] * v0[col];\r\n for (uint i = cb; i < ce; ++i)\r\n {\r\n dot_product += msc_non_zero[i] * v0[msc_non_zero_row[i]];\r\n }\r\n v1[col] = dot_product;\r\n\r\n sum[col] += fgw_w * dot_product;\r\n }\r\n}\r\n\r\n";

#endif // FOXGLYNN_OPENCL_KERNEL_SOURCE
